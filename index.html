<!DOCTYPE html>
<html lang="no">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Sjekk badevilk√•rene ved Havet Arena, Nyhavna i Trondheim. Oppdaterte bakterieverdier hver uke.">
    <meta name="keywords" content="Havet Arena, Nyhavna, bading, bakterier, E. coli, Trondheim">
    <meta property="og:title" content="Havet Arena - Badevilk√•r">
    <meta property="og:description" content="Sjekk om det er trygt √• bade i dag">
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://havet.app">
    <meta property="og:image" content="https://havet.app/og-image.png">
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="Havet Arena - Badevilk√•r">
    <meta name="twitter:description" content="Sjekk badevilk√•rene ved Havet Arena, Nyhavna i Trondheim.">
    <meta name="twitter:image" content="https://havet.app/og-image.png">
    <title>Havet Arena - Badevilk√•r</title>
        <!-- Favicon med sauna/badende emoji -->
        <link rel="icon" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 64 64'%3E%3Ctext y='50%25' x='50%25' font-size='52' text-anchor='middle' dominant-baseline='central'%3E%F0%9F%8F%8A%E2%80%8D%E2%99%80%EF%B8%8F%3C/text%3E%3C/svg%3E">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }

        .container {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            padding: 40px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            text-align: center;
            max-width: 600px;
            width: 100%;
        }

        h1 {
            color: #2c3e50;
            margin-bottom: 10px;
            font-size: 2.5em;
        }

        .subtitle {
            color: #7f8c8d;
            margin-bottom: 30px;
            font-size: 1.1em;
        }

        .value-display {
            font-size: 4em;
            font-weight: bold;
            padding: 30px;
            border-radius: 15px;
            margin: 30px 0;
            transition: all 0.3s ease;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
        }

        .value-display.green {
            background: linear-gradient(135deg, #11998e 0%, #38ef7d 100%);
            color: white;
        }

        .value-display.red {
            background: linear-gradient(135deg, #eb3349 0%, #f45c43 100%);
            color: white;
        }

        .status-text {
            font-size: 1.3em;
            margin-top: 20px;
            font-weight: 600;
        }

        .status-text.green {
            color: #27ae60;
        }

        .status-text.red {
            color: #e74c3c;
        }

        .week-info {
            color: #7f8c8d;
            margin-top: 20px;
            font-size: 0.9em;
        }

        .temperature-container {
            display: flex;
            justify-content: center;
            gap: 30px;
            margin: 15px 0;
            flex-wrap: wrap;
        }

        .temperature-display {
            color: #2c3e50;
            font-size: 1.2em;
            font-weight: 500;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }

        .temp-icon {
            font-size: 1.3em;
        }

        #tempValue, #seaTempValue {
            font-weight: 600;
        }

        .loading {
            color: #7f8c8d;
            font-size: 1.2em;
            position: relative;
        }

        .loading::after {
            content: '...';
            animation: dots 1.5s steps(4, end) infinite;
        }

        @keyframes dots {
            0%, 20% { content: '.'; }
            40% { content: '..'; }
            60%, 100% { content: '...'; }
        }

        .error {
            color: #e74c3c;
            background: #ffe6e6;
            padding: 15px;
            border-radius: 10px;
            margin-top: 20px;
            line-height: 1.6;
            text-align: left;
            white-space: pre-wrap;
        }
        
        .error a {
            color: #667eea;
            text-decoration: underline;
        }

        .sauna-icon {
            font-size: 3em;
            margin-bottom: 20px;
        }

        .info-section {
            margin-top: 30px;
            padding: 20px;
            background: #f8f9fa;
            border-radius: 10px;
            text-align: left;
            font-size: 0.9em;
            color: #2c3e50;
        }

        .info-section h3 {
            color: #2c3e50;
            margin-bottom: 15px;
            font-size: 1.1em;
            text-align: center;
        }

        .info-section ul {
            list-style: none;
            padding-left: 0;
        }

        .info-section li {
            margin: 10px 0;
            padding-left: 25px;
            position: relative;
        }

        .info-section li:before {
            content: "‚Ä¢";
            position: absolute;
            left: 10px;
            color: #667eea;
            font-weight: bold;
        }

        .info-section a {
            color: #667eea;
            text-decoration: none;
            font-weight: 600;
        }

        .info-section a:hover {
            text-decoration: underline;
        }

        .warning-box {
            background: #fff3cd;
            border-left: 4px solid #ffc107;
            padding: 15px;
            margin: 15px 0;
            border-radius: 5px;
            font-size: 0.9em;
        }

        .sampling-info {
            background: #e7f3ff;
            border-left: 4px solid #2196F3;
            padding: 15px;
            margin: 15px 0;
            border-radius: 5px;
            font-size: 0.9em;
        }

        .history-chart {
            margin-top: 15px;
            display: flex;
            justify-content: center;
        }

        /* Responsivt for mobil */
        @media (max-width: 600px) {
            .container {
                padding: 20px;
                margin: 10px;
            }
            
            h1 {
                font-size: 1.8em;
            }
            
            .value-display {
                font-size: 3em;
                padding: 20px;
            }
            
            .info-section {
                font-size: 0.85em;
            }
        }

        /* M√∏rk modus */
        @media (prefers-color-scheme: dark) {
            body {
                background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            }
            
            .container {
                background: rgba(30, 30, 46, 0.95);
                color: #e0e0e0;
            }
            
            h1, .info-section h3 {
                color: #e0e0e0;
            }

            .temperature-display {
                color: #e0e0e0;
            }

            .temperature-container {
                gap: 20px;
            }

            .info-section {
                background: #202133;
                color: #e0e0e0;
            }

            .warning-box {
                background: #4a3b1a;
                border-left-color: #ffc107;
            }

            .sampling-info {
                background: #1b2a3d;
                border-left-color: #64b5f6;
            }

            .info-section a {
                color: #9fa8ff;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="sauna-icon">üèä‚Äç‚ôÇÔ∏è</div>
        <h1>Havet Arena</h1>
        <div class="temperature-container">
            <div id="temperature" class="temperature-display" style="display: none;">
                <span class="temp-icon">üå°Ô∏è</span>
                <span id="tempValue">-</span>¬∞C
            </div>
            <div id="seaTemperature" class="temperature-display" style="display: none;">
                <span class="temp-icon">üåä</span>
                <span id="seaTempValue">-</span>¬∞C
            </div>
        </div>
        <p class="subtitle">Bakterieverdier per 100 ml denne uken:</p>
        
        <div id="loading" class="loading">Henter data...</div>
        
        <div id="content" style="display: none;">
            <div id="valueDisplay" class="value-display" role="status" aria-live="polite" aria-label="E. coli verdi">-</div>
            <div id="statusText" class="status-text" role="alert" aria-live="assertive"></div>
            <div class="week-info" id="weekInfo"></div>
            <div id="historyChart" class="history-chart" aria-hidden="true"></div>
        </div>
        
        <div id="error" class="error" style="display: none;"></div>

        <div class="info-section">
            <h3>üìã Om Nyhavna</h3>
            
            <div class="sampling-info">
                <strong>Pr√∏vetaking:</strong><br>
                ‚Ä¢ Klima- og milj√∏enheten: Hver torsdag<br>
                ‚Ä¢ Havet Arena: Hver mandag<br>
                ‚Ä¢ Resultater publiseres fortl√∏pende (1-2 dager etter pr√∏vetaking)
            </div>

            <div class="warning-box">
                <strong>‚ö†Ô∏è Viktig informasjon:</strong><br>
                Nyhavna har "D√•rlig" badevannskvalitet basert p√• siste 3 √•r. Ved vedvarende h√∏ye bakterieverdier frar√•des bading.
            </div>

            <ul>
                <li><strong>Anbefaling:</strong> Avvent bading inntil et d√∏gn etter regnv√¶r, spesielt p√• sentrumsn√¶re strender</li>
                <li><strong>Grenseverdier for oppf√∏lgingspr√∏ver:</strong>
                    <ul style="margin-top: 5px; padding-left: 20px;">
                        <li>E. coli: 500 CFU pr. 100 ml</li>
                        <li>Intestinale enterokokker: 200 CFU pr. 100 ml (saltvann)</li>
                    </ul>
                </li>
                <li>Dette er en hel√•rsbadeplass med tilrettelagt bading hele √•ret</li>
            </ul>

            <p style="margin-top: 15px; text-align: center;">
                <a href="https://www.trondheim.kommune.no/badevannskvalitet" target="_blank">
                    Se detaljerte resultater hos Trondheim kommune ‚Üí
                </a>
            </p>
        </div>
    </div>

    <script>
        // === KONFIGURASJON ===
        const CONFIG = {
            DOC_ID: '1RjJTWQTPRwHtWC-fi1QnelKcpBXXB3eLw7Ld-beK2TE',
            IS_DOCUMENT: true,
            DEBUG: false,
            CACHE_KEY: 'havet_arena_data',
            CACHE_DURATION: 1000 * 60 * 60, // 1 time
            CACHE_VERSION: 4, // bump denne hvis datastruktur endres
            THRESHOLD_HIGH: 1000, // CFU/100ml
            RETRY_ATTEMPTS: 3,
            RETRY_DELAY: 1000
        };

        let CURRENT_REQUEST_ID = 0; // Brukes til √• unng√• race condition ved flere samtidige kall

        // === HJELPEFUNKSJONER ===

        // Hjelpefunksjon for fetch med timeout, slik at proxy-feil ikke henger
        async function fetchWithTimeout(url, options = {}, timeoutMs = 10000) {
            const controller = new AbortController();
            const timeout = setTimeout(() => controller.abort(), timeoutMs);
            try {
                const response = await fetch(url, { ...options, signal: controller.signal });
                return response;
            } catch (err) {
                // Gir mer informativ feil om det var et tidsavbrudd
                if (err.name === 'AbortError') {
                    throw new Error(`Tidsavbrudd etter ${timeoutMs / 1000}s mot ${url}`);
                }
                throw err;
            } finally {
                clearTimeout(timeout);
            }
        }

        async function fetchWithRetry(fetchFn, maxRetries = CONFIG.RETRY_ATTEMPTS, delay = CONFIG.RETRY_DELAY) {
            for (let i = 0; i < maxRetries; i++) {
                try {
                    return await fetchFn();
                } catch (error) {
                    if (i === maxRetries - 1) throw error;
                    log(`Fors√∏k ${i + 1} feilet, pr√∏ver igjen om ${delay}ms...`);
                    await new Promise(resolve => setTimeout(resolve, delay));
                    delay *= 2; // Exponential backoff
                }
            }
        }

        // Hjelpefunksjon for logging som kan skrus av/p√•
        function log(...args) {
            if (CONFIG.DEBUG) {
                console.log(...args);
            }
        }
        
        // === DATA-HENTING ===
        
        // Hent v√¶rtemperatur fra Open-Meteo API
        async function getTempAtHavetSauna() {
            const lat = 63.44181021566446;
            const lon = 10.42506878174522;

            const url =
                "https://api.open-meteo.com/v1/forecast"
                + `?latitude=${lat}&longitude=${lon}`
                + "&current=temperature_2m"
                + "&timezone=Europe%2FOslo";

            const res = await fetch(url);
            if (!res.ok) throw new Error(`Open-Meteo failed: ${res.status}`);

            const data = await res.json();

            // Returnerer kun temperatur (¬∞C)
            return data?.current?.temperature_2m;
        }

        // Oppdater temperatur i UI
        async function updateTemperature() {
            try {
                const temp = await getTempAtHavetSauna();
                const tempElement = document.getElementById('temperature');
                const tempValue = document.getElementById('tempValue');
                
                if (tempElement && tempValue && temp !== null && temp !== undefined) {
                    tempValue.textContent = Math.round(temp);
                    tempElement.style.display = 'flex';
                }
            } catch (error) {
                log('Kunne ikke hente temperatur:', error);
                // Ikke vis feilmelding for temperatur - det er ikke kritisk
            }
        }

        // Hent badetemperatur fra Havvarsel API eller nettside
        async function getSeaTemperatureAtHavetArena() {
            const lat = 63.44181;
            const lon = 10.42506;
            
            // Pr√∏v API f√∏rst
            const apiUrl = `https://api.havvarsel.no/apis/duapi/havvarsel/v2/temperatureprojection/${lon}/${lat}`;
            log('Henter badetemperatur fra API:', apiUrl);
            
            try {
                const res = await fetchWithRetry(() => fetchWithTimeout(apiUrl, {
                    method: 'GET',
                    mode: 'cors',
                    headers: {
                        'Accept': 'application/json'
                    }
                }));
                
                if (!res.ok) {
                    log('Havvarsel API respons ikke OK:', res.status, res.statusText);
                    throw new Error(`Havvarsel API foresp√∏rsel feilet: ${res.status}`);
                }

                const data = await res.json();
                log('Havvarsel API data mottatt:', data);

                // Pr√∏v forskjellige mulige strukturer
                const temp = data?.temperature || data?.temp || data?.value || 
                            (data?.data && (data.data.temperature || data.data.temp || data.data.value)) ||
                            (Array.isArray(data) && data[0]?.temperature) ||
                            null;

                if (temp !== null) {
                    return temp;
                }
                
                log('Kunne ikke finne temperatur i API-respons. Struktur:', JSON.stringify(data));
            } catch (error) {
                log('Direkte API-fetch feilet, pr√∏ver via proxy...', error);
                // Fallback: Pr√∏v via en CORS-proxy hvis direkte kall feiler
                const proxyUrl = `https://api.allorigins.win/raw?url=${encodeURIComponent(apiUrl)}`;
                try {
                    const proxyResponse = await fetchWithRetry(() => fetchWithTimeout(proxyUrl, {}, 10000));
                    if (proxyResponse.ok) {
                const data = await proxyResponse.json();
                log('Havvarsel API data mottatt via proxy:', data);
                log('Fullstendig API-struktur:', JSON.stringify(data, null, 2));

                // Pr√∏v forskjellige mulige strukturer basert p√• det vi ser i loggen
                let temp = null;
                
                // Sjekk om det er en variables-array (som vi ser i loggen)
                if (data?.variables && Array.isArray(data.variables) && data.variables.length > 0) {
                    const variable = data.variables[0];
                    // variable.data er en array med objekter som har {value, rawTime}
                    if (variable?.data && Array.isArray(variable.data) && variable.data.length > 0) {
                        // Ta den f√∏rste (n√•v√¶rende) temperaturen
                        temp = variable.data[0]?.value;
                        log('Fant temperatur i variables[0].data[0].value:', temp);
                    } else {
                        // Fallback til direkte felter hvis data-array ikke finnes
                        temp = variable?.value || variable?.temperature || variable?.temp;
                        log('Fant temperatur i variables[0] (fallback):', temp);
                    }
                }
                
                // Pr√∏v ogs√• direkte felter
                if (temp === null || temp === undefined) {
                    temp = data?.temperature || data?.temp || data?.value || 
                           data?.current?.temperature || data?.current?.temp ||
                           (data?.data && (data.data.temperature || data.data.temp || data.data.value)) ||
                           (Array.isArray(data) && data[0]?.temperature) ||
                           null;
                }
                
                // Sjekk queryPoint eller closestGridPoint
                if (temp === null || temp === undefined) {
                    if (data?.queryPoint?.temperature) temp = data.queryPoint.temperature;
                    if (data?.closestGridPoint?.temperature) temp = data.closestGridPoint.temperature;
                    if (data?.closestGridPointWithData?.temperature) temp = data.closestGridPointWithData.temperature;
                    // Sjekk om det er verdier i queryPoint
                    if (data?.queryPoint?.values && Array.isArray(data.queryPoint.values) && data.queryPoint.values.length > 0) {
                        temp = data.queryPoint.values[0];
                    }
                }

                if (temp !== null && temp !== undefined) {
                    log('Fant temperatur:', temp);
                    return temp;
                } else {
                    log('Kunne ikke finne temperatur i API-respons. Struktur:', JSON.stringify(data, null, 2));
                }
                    }
                } catch (proxyError) {
                    log('Proxy feilet ogs√•:', proxyError);
                }
            }
            
            // Fallback: Pr√∏v √• hente fra nettsiden direkte
            log('Pr√∏ver √• hente fra havvarsel.no nettside...');
            try {
                const pageUrl = `https://havvarsel.no/oversikt/${lat}/${lon}`;
                const proxyPageUrl = `https://api.allorigins.win/raw?url=${encodeURIComponent(pageUrl)}`;
                const pageResponse = await fetchWithRetry(() => fetchWithTimeout(proxyPageUrl, {}, 15000));
                
                if (pageResponse.ok) {
                    const html = await pageResponse.text();
                    log('Havvarsel.no HTML mottatt, lengde:', html.length);
                    
                    // Pr√∏v √• finne temperatur i HTML (s√∏k etter tall etter "badetemperatur" eller lignende)
                    const tempMatch = html.match(/(?:badetemperatur|vann?temp|sea.*temp)[^>]*>[\s\S]*?(\d+(?:[.,]\d+)?)\s*¬∞?C/i) ||
                                    html.match(/(\d+(?:[.,]\d+)?)\s*¬∞?C[^<]*badetemperatur/i) ||
                                    html.match(/badetemperatur[^>]*>[\s\S]{0,200}?(\d+(?:[.,]\d+)?)/i);
                    
                    if (tempMatch && tempMatch[1]) {
                        const temp = parseFloat(tempMatch[1].replace(',', '.'));
                        if (!isNaN(temp)) {
                            log('Fant badetemperatur i HTML:', temp);
                            return temp;
                        }
                    }
                    
                    log('Kunne ikke finne badetemperatur i HTML');
                }
            } catch (pageError) {
                log('Kunne ikke hente fra nettside:', pageError);
            }
            
            // Hvis alt feiler, returner null
            log('Kunne ikke hente badetemperatur fra noen kilde');
            return null;
        }

        // Oppdater badetemperatur i UI
        async function updateSeaTemperature() {
            try {
                const temp = await getSeaTemperatureAtHavetArena();
                const seaTempElement = document.getElementById('seaTemperature');
                const seaTempValue = document.getElementById('seaTempValue');
                
                log('Badetemperatur hentet:', temp);
                
                if (seaTempElement && seaTempValue && temp !== null && temp !== undefined) {
                    seaTempValue.textContent = Math.round(temp);
                    seaTempElement.style.display = 'flex';
                    log('Badetemperatur oppdatert i UI:', Math.round(temp));
                } else {
                    log('Kunne ikke oppdatere badetemperatur - elementer eller verdi mangler:', {
                        seaTempElement: !!seaTempElement,
                        seaTempValue: !!seaTempValue,
                        temp: temp
                    });
                }
            } catch (error) {
                console.error('Kunne ikke hente badetemperatur:', error);
                log('Kunne ikke hente badetemperatur:', error);
                // Ikke vis feilmelding for temperatur - det er ikke kritisk
            }
        }
        
        // Hjelpefunksjon for √• hente HTML fra dokumentet
        async function fetchDocumentHTML() {
            const htmlUrl = `https://docs.google.com/document/d/${CONFIG.DOC_ID}/export?format=html`;
            log('Henter HTML fra:', htmlUrl);
            try {
                const response = await fetchWithRetry(() => fetchWithTimeout(htmlUrl, {
                    method: 'GET',
                    mode: 'cors', // Pr√∏v med 'cors' f√∏rst
                    headers: {
                        'Accept': 'text/html'
                    }
                }));
                if (!response.ok) throw new Error(`HTTP ${response.status}: Kunne ikke hente dokument`);
                return await response.text();
            } catch (error) {
                log('Direkte fetch feilet, pr√∏ver via proxy...', error);
                // Fallback: Pr√∏v via en CORS-proxy hvis direkte kall feiler
                // Merk: Dette er en offentlig proxy, bruk med varsomhet i produksjon
                const proxyUrl = `https://api.allorigins.win/raw?url=${encodeURIComponent(htmlUrl)}`;
                const proxyResponse = await fetchWithRetry(() => fetchWithTimeout(proxyUrl, {}, 10000));
                if (!proxyResponse.ok) throw new Error(`Proxy HTTP ${proxyResponse.status}: Kunne ikke hente dokument via proxy`);
                return await proxyResponse.text();
            }
        }

        // Hjelpefunksjon for √• konvertere HTML til CSV
        // Velger alltid tabeller for riktig √•r (innev√¶rende √•r hvis mulig, ellers siste √•r i dokumentet)
        function parseHTMLToCSV(html) {
            // Klipp bort alt innhold fra og med "Resultater for 2024"
            // slik at vi kun har 2025-seksjonen i dokumentet.
            const cutoffMarker = 'Resultater for 2024';
            const cutoffIndex = html.indexOf(cutoffMarker);
            if (cutoffIndex !== -1) {
                log(`Fant "${cutoffMarker}" i HTML p√• posisjon ${cutoffIndex} ‚Äì klipper bort alt etter dette (2024-data ignoreres).`);
                html = html.slice(0, cutoffIndex);
            } else {
                log(`Fant ikke "${cutoffMarker}" i HTML ‚Äì bruker hele dokumentet.`);
            }

            const parser = new DOMParser();
            const doc = parser.parseFromString(html, 'text/html');
            const allTables = Array.from(doc.querySelectorAll('table'));
            
            log('Antall tabeller funnet (etter 2024-cutoff):', allTables.length);
            
            if (allTables.length === 0) {
                log('Ingen <table> elementer funnet, s√∏ker etter alternativ struktur...');
                const allText = doc.body.textContent || doc.body.innerText || '';
                log('Dokument tekst (f√∏rste 1000 tegn):', allText.substring(0, 1000));
                throw new Error('Ingen tabeller funnet i dokumentet. Dokumentet kan ha en annen struktur.');
            }
            
            const csvLines = [];
            let combinedHeader = null;
            const dataRows = [];
            
            // For hver tabell:
            // - Finn raden der f√∏rste celle inneholder "Pr√∏vepunkt" => header-rad
            // - Bruk raden "Havet Arena" som eneste datarad
            allTables.forEach((table, tableIndex) => {
                const rows = Array.from(table.querySelectorAll('tr'));
                log(`Tabell ${tableIndex + 1}: ${rows.length} rader`);
                
                let headerRowIndex = -1;
                rows.forEach((row, rowIndex) => {
                    const firstCell = row.querySelector('td, th');
                    const text = firstCell ? (firstCell.textContent || '').toLowerCase().trim() : '';
                    if (text.includes('pr√∏vepunkt')) {
                        headerRowIndex = rowIndex;
                    }
                });

                if (headerRowIndex === -1) {
                    log(`Tabell ${tableIndex + 1}: Fant ingen rad med "Pr√∏vepunkt" ‚Äì hopper over tabellen`);
                    return;
                }
                
                rows.forEach((row, rowIndex) => {
                    const cells = row.querySelectorAll('td, th');
                    const values = Array.from(cells).map(cell => {
                        let val = cell.textContent.trim();
                        if (val.includes(',') || val.includes('"') || val.includes('\n')) {
                            val = '"' + val.replace(/"/g, '""') + '"';
                        }
                        return val;
                    });
                    
                    if (values.length === 0) return;

                        if (rowIndex === headerRowIndex) {
                        // Header-rad
                            if (combinedHeader === null) {
                                combinedHeader = [...values];
                                log(`Header fra tabell ${tableIndex + 1}:`, values.slice(0, 5));
                            } else {
                                const weekColumns = values.slice(1);
                                combinedHeader.push(...weekColumns);
                            }
                        } else {
                        // Data-rad
                            const rowName = values[0].toLowerCase().trim();
                        if (!rowName) return;
                        if (rowName.includes('havet') && rowName.includes('arena')) {
                            const rowData = values.slice(1);
                            if (!dataRows[0]) dataRows[0] = [values[0]];
                            dataRows[0].push(...rowData);
                        }
                        // Rader for Strandveikaia ignoreres eksplisitt
                    }
                });
            });
            
            if (combinedHeader) csvLines.push(combinedHeader.join(','));
            dataRows.forEach(row => { if (row) csvLines.push(row.join(',')); });
            
            return csvLines.join('\n');
        }

        // Finn beste uke-match gitt tilgjengelige uke-kolonner
        function findBestWeekMatch(weekColumns, targetWeek) {
            // 1. Eksakt match
            let match = weekColumns.find(w => w.week === targetWeek);
            if (match) return { ...match, matchType: 'exact' };
            
            // 2. N√¶rmeste fremtidige uke (prioriter nyere data)
            const futureWeeks = weekColumns
                .filter(w => w.week > targetWeek)
                .sort((a, b) => a.week - b.week);
            if (futureWeeks.length > 0) {
                return { ...futureWeeks[0], matchType: 'future' };
            }
            
            // 3. N√¶rmeste fortidige uke
            const pastWeeks = weekColumns
                .filter(w => w.week < targetWeek)
                .sort((a, b) => b.week - a.week);
            if (pastWeeks.length > 0) {
                return { ...pastWeeks[0], matchType: 'past' };
            }
            
            return null;
        }

        // Funksjon for √• hente data fra Google Document (HTML-parsing)
        async function fetchDocumentData() {
            try {
                // Pr√∏v √• hente HTML-versjonen av dokumentet
                const html = await fetchDocumentHTML();
                
                log('HTML mottatt, lengde:', html.length);
                // Sjekk om HTML inneholder et innebygd Google Sheet
                const sheetMatch = html.match(/spreadsheets\/d\/([a-zA-Z0-9_-]+)/);
                if (sheetMatch) {
                    log('Fant innebygd Sheet ID i dokumentet:', sheetMatch[1]);
                }
                
                const csv = parseHTMLToCSV(html);
                log('CSV generert, antall linjer:', csv.split('\n').length);
                
                return csv;
            } catch (error) {
                console.error('Feil ved henting av dokument:', error);
                throw error;
            }
        }
        
        // === PARSING / DATOBEHANDLING ===
        // Funksjon for √• f√• ukenummer (ISO 8601) og √•r for uken (viktig rundt √•rsskifte)
        function getWeekNumber(date) {
            const d = new Date(Date.UTC(date.getFullYear(), date.getMonth(), date.getDate()));
            const dayNum = d.getUTCDay() || 7;
            d.setUTCDate(d.getUTCDate() + 4 - dayNum);
            const yearStart = new Date(Date.UTC(d.getUTCFullYear(), 0, 1));
            const weekNum = Math.ceil((((d - yearStart) / 86400000) + 1) / 7);
            return { week: weekNum, year: d.getUTCFullYear() };
        }

        // Funksjon for √• parse CSV (h√•ndterer kommaer i celler)
        function parseCSV(text) {
            const lines = [];
            let row = [];
            let field = '';
            let inQuotes = false;
            
            for (let i = 0; i < text.length; i++) {
                const char = text[i];
                const next = text[i + 1];
                
                if (char === '"') {
                    // H√•ndter escape av anf√∏rselstegn ("")
                    if (inQuotes && next === '"') {
                        field += '"';
                        i++; // hopp over neste "
                        continue;
                    }
                    inQuotes = !inQuotes;
                    continue;
                }

                if (!inQuotes && (char === '\n' || char === '\r')) {
                    // H√•ndter CRLF som linjeskift
                    if (char === '\r' && next === '\n') i++;
                    row.push(field.trim());
                    if (row.some(cell => cell !== '')) lines.push(row);
                    row = [];
                    field = '';
                    continue;
                }

                if (char === ',' && !inQuotes) {
                    row.push(field.trim());
                    field = '';
                    continue;
                }

                field += char;
            }
            
            // Flush siste felt/linje
            if (field.length > 0 || row.length > 0) {
                row.push(field.trim());
                if (row.some(cell => cell !== '')) lines.push(row);
            }
            
            return lines;
        }

        // Funksjon for √• hente data fra Google Sheets eller Documents
        async function fetchSheetData() {
            try {
                // Hvis det er et Document, bruk Document-metoden
                if (CONFIG.IS_DOCUMENT) {
                    log('Henter data fra Google Document...');
                    try {
                        const csvText = await fetchDocumentData();
                        const lines = parseCSV(csvText);
                        log('CSV parset, antall linjer:', lines.length);
                        if (lines.length > 0) {
                            log('F√∏rste linje:', lines[0]);
                            log('Andre linje:', lines.length > 1 ? lines[1] : 'Ingen');
                        }
                        return processSheetData(lines);
                    } catch (docError) {
                        console.error('Feil ved henting av Document:', docError);
                        // Pr√∏v alternativ metode - hent som plain text
                        log('Pr√∏ver alternativ metode...');
                        try {
                        const textUrl = `https://docs.google.com/document/d/${CONFIG.DOC_ID}/export?format=txt`;
                            const textResponse = await fetchWithRetry(() => fetchWithTimeout(textUrl));
                            if (textResponse.ok) {
                                const text = await textResponse.text();
                                log('Plain text mottatt, lengde:', text.length);
                                log('F√∏rste 1000 tegn:', text.substring(0, 1000));
                                // Pr√∏v √• parse som CSV hvis det ser ut som CSV
                                const lines = parseCSV(text);
                                if (lines.length > 0) {
                                    return processSheetData(lines);
                                }
                            }
                        } catch (textError) {
                            console.error('Alternativ metode feilet ogs√•:', textError);
                        }
                        throw docError;
                    }
                }
                
                // Hvis det er et Sheet, bruk Sheet-metoden
                log('Henter data fra Google Sheet...');
                // Pr√∏v flere URL-formater for √• hente CSV fra offentlige Sheets
                const urls = [
                    // Standard export-format
                    `https://docs.google.com/spreadsheets/d/${CONFIG.DOC_ID}/export?format=csv&gid=0`,
                    // Uten gid (bruker f√∏rste ark)
                    `https://docs.google.com/spreadsheets/d/${CONFIG.DOC_ID}/export?format=csv`,
                    // Google Visualization API format
                    `https://docs.google.com/spreadsheets/d/${CONFIG.DOC_ID}/gviz/tq?tqx=out:csv&gid=0`,
                    // Uten gid i gviz
                    `https://docs.google.com/spreadsheets/d/${CONFIG.DOC_ID}/gviz/tq?tqx=out:csv`,
                    // Med sheet=0 parameter
                    `https://docs.google.com/spreadsheets/d/${CONFIG.DOC_ID}/export?format=csv&sheet=0`
                ];
                
                let csvText = null;
                let lastError = null;
                let lastStatus = null;
                
                // Pr√∏v hver URL til en fungerer
                for (const csvUrl of urls) {
                    try {
                        log('Pr√∏ver URL:', csvUrl);
                        const response = await fetchWithRetry(() => fetch(csvUrl, {
                            method: 'GET',
                            mode: 'cors',
                            redirect: 'follow'
                        }));
                        
                        lastStatus = response.status;
                        
                        if (response.ok) {
                            csvText = await response.text();
                            log('Fikk respons, lengde:', csvText.length);
                            
                            // Sjekk om vi faktisk fikk CSV-data (ikke en HTML-feilside)
                            if (csvText && 
                                csvText.length > 0 && 
                                !csvText.includes('<html') && 
                                !csvText.includes('<!DOCTYPE') &&
                                !csvText.includes('Sign in') &&
                                !csvText.includes('Access denied')) {
                                log('CSV-data funnet!');
                                break;
                            } else {
                                log('Fikk HTML i stedet for CSV');
                                csvText = null;
                            }
                        } else {
                            log('Response ikke OK:', response.status, response.statusText);
                        }
                    } catch (err) {
                        log('Feil ved henting:', err.message);
                        lastError = err;
                        continue;
                    }
                }
                
                if (!csvText) {
                    // Pr√∏v √• hente via JSON og konverter til CSV
                    try {
                        log('Pr√∏ver JSON-alternativ...');
                        const jsonUrl = `https://docs.google.com/spreadsheets/d/${CONFIG.DOC_ID}/gviz/tq?tqx=out:json&gid=0`;
                        const jsonResponse = await fetchWithRetry(() => fetch(jsonUrl));
                        
                        if (jsonResponse.ok) {
                            const jsonText = await jsonResponse.text();
                            // Fjern Google's wrapper: )]}'\n
                            const cleanJson = jsonText.replace(/^\)\]\}'\n/, '');
                            const data = JSON.parse(cleanJson);
                            
                            // Konverter JSON til CSV
                            if (data.table && data.table.rows) {
                                const rows = data.table.rows;
                                const csvLines = [];
                                
                                // Legg til headers hvis de finnes
                                if (data.table.cols) {
                                    const headers = data.table.cols.map(col => col.label || '');
                                    csvLines.push(headers.join(','));
                                }
                                
                                // Legg til rader
                                rows.forEach(row => {
                                    if (!row || !row.c) return; // Guard mot tomme rader
                                    const values = row.c.map(cell => {
                                        if (!cell || cell.v === null || cell.v === undefined) return '';
                                        // Escape kommaer og anf√∏rselstegn
                                        const val = String(cell.v);
                                        if (val.includes(',') || val.includes('"') || val.includes('\n')) {
                                            return '"' + val.replace(/"/g, '""') + '"';
                                        }
                                        return val;
                                    });
                                    csvLines.push(values.join(','));
                                });
                                
                                csvText = csvLines.join('\n');
                                log('Konvertert JSON til CSV');
                            }
                        }
                    } catch (jsonErr) {
                        log('JSON-alternativ feilet:', jsonErr);
                    }
                }
                
                if (!csvText) {
                    // Sjekk om Document/Sheet ID-en faktisk eksisterer
                    const docUrl = CONFIG.IS_DOCUMENT 
                        ? `https://docs.google.com/document/d/${CONFIG.DOC_ID}`
                        : `https://docs.google.com/spreadsheets/d/${CONFIG.DOC_ID}`;
                    let errorDetails = `HTTP ${lastStatus || '404'}: Kunne ikke hente data.\n\n`;
                    errorDetails += `${CONFIG.IS_DOCUMENT ? 'Document' : 'Sheet'} ID: ${CONFIG.DOC_ID}\n\n`;
                    errorDetails += `‚ö†Ô∏è ${CONFIG.IS_DOCUMENT ? 'Dokumentet' : 'Regnearket'} finnes ikke eller er ikke tilgjengelig.\n\n`;
                    errorDetails += `Sjekk:\n`;
                    errorDetails += `‚Ä¢ Er ID-en korrekt?\n`;
                    errorDetails += `‚Ä¢ Er ${CONFIG.IS_DOCUMENT ? 'dokumentet' : 'regnearket'} offentlig? (Anyone with the link can view)\n`;
                    errorDetails += `‚Ä¢ Pr√∏v √• √•pne dette i nettleseren: ${docUrl}\n\n`;
                    errorDetails += `üí° For √• finne riktig ID:\n`;
                    errorDetails += `1. √Öpne ${CONFIG.IS_DOCUMENT ? 'dokumentet' : 'regnearket'} i Google\n`;
                    errorDetails += `2. Se i URL-en etter /d/ID/\n`;
                    errorDetails += `3. Kopier ID-en og oppdater konstanten DOC_ID i koden`;
                    
                    throw new Error(errorDetails);
                }
                
                const lines = parseCSV(csvText);
                return processSheetData(lines);
                
            } catch (error) {
                console.error('Feil ved henting av data:', error);
                throw error;
            }
        }
        
        // Funksjon for √• prosessere CSV-data og finne uke-verdi
        function processSheetData(lines) {
            if (lines.length === 0) {
                throw new Error('Dataene er tomme');
            }
            
            // Finn gjeldende uke
            const currentDate = new Date();
            const { week: currentWeek, year: currentYear } = getWeekNumber(currentDate);
            
            log('S√∏ker etter uke:', currentWeek, 'i √•r:', currentYear);
            log('Antall rader i data:', lines.length);
            
            // Log alle rader for debugging (f√∏rste 10 rader)
            log('F√∏rste 10 rader i data:');
            for (let i = 0; i < Math.min(10, lines.length); i++) {
                log(`Rad ${i}:`, lines[i]);
            }
            
            // Finn header-raden som inneholder uke-kolonner
            // Strukturen ser ut til √• v√¶re:
            // Rad 0: "Resultater for 2025" (kan hoppes over)
            // Rad 1: "Pr√∏vepunkt | Uke 1 | Uke 2 | ..." (header-rad)
            // Rad 2+: Data-rader med "Havet Arena", "Strandveikaia", osv.
            
            let headerRowIndex = -1;
            let weekColumnIndex = -1;
            let havetArenaRowIndex = -1;
            const foundWeeks = [];
            
            // Finn header-raden (den som inneholder "Pr√∏vepunkt" og uke-kolonner)
            for (let i = 0; i < lines.length; i++) {
                const row = lines[i];
                // Sjekk om raden inneholder "Pr√∏vepunkt" OG minst √©n celle med "Uke" eller "Week"
                // Dette er mer robust enn √• lete etter spesifikt "Uke 1"
                const rowText = row.join(' ').toLowerCase();
                if (rowText.includes('pr√∏vepunkt') && (rowText.includes('uke') || rowText.includes('week'))) {
                    headerRowIndex = i;
                    log('Fant header-rad p√• indeks:', i);
                    break;
                }
            }
            
            if (headerRowIndex === -1) {
                // Fallback: Pr√∏v gammel metode hvis "Pr√∏vepunkt" mangler
                log('Fant ikke "Pr√∏vepunkt", pr√∏ver fallback-s√∏k etter "Uke 1"...');
                for (let i = 0; i < lines.length; i++) {
                    const row = lines[i];
                    for (let j = 0; j < row.length; j++) {
                        const cell = row[j].toLowerCase().trim();
                        if (cell.includes('uke 1') || cell.includes('week 1')) {
                            headerRowIndex = i;
                            break;
                        }
                    }
                    if (headerRowIndex !== -1) break;
                }
            }
            
            if (headerRowIndex === -1) {
                throw new Error('Kunne ikke finne header-rad med uke-kolonner');
            }
            
            const headerRow = lines[headerRowIndex];
            log('Header-rad:', headerRow);
            log('Header-rad lengde:', headerRow.length);
            log('F√∏rste 20 kolonner i header:', headerRow.slice(0, 20));
            
            // F√∏rst: Samle alle uke-verdier og deres kolonne-indekser.
            // Dersom samme uke finnes flere ganger (f.eks. flere √•r), lar vi SISTE forekomst vinne
            // slik at nye data (senere i dokumentet) overstyrer gamle.
            const weekColumnByWeek = {}; // weekNum -> {week, columnIndex}
            
            for (let j = 0; j < headerRow.length; j++) {
                const headerCell = headerRow[j].toLowerCase().trim();
                
                // Pr√∏v √• finne uke-nummeret i header-cell
                const weekMatch = headerCell.match(/(?:uke|week)\s*(\d+)/i);
                if (weekMatch) {
                    const weekNum = parseInt(weekMatch[1]);
                    foundWeeks.push(weekNum);
                    weekColumnByWeek[weekNum] = { week: weekNum, columnIndex: j };
                    log(`Fant uke ${weekNum} p√• kolonne-indeks ${j} (cell: "${headerRow[j]}")`);
                } else if (j < 20) {
                    // Log f√∏rste 20 celler som ikke matcher for debugging
                    log(`Kolonne ${j} er ikke en uke: "${headerRow[j]}"`);
                }
            }
            
            const weekColumns = Object.values(weekColumnByWeek);
            log('Alle funnede uker (etter at siste forekomst per uke vinner):', weekColumns.map(w => `Uke ${w.week} (kol ${w.columnIndex})`).join(', '));
            log(`S√∏ker etter uke ${currentWeek}. Funnet ${weekColumns.length} uke-kolonner totalt.`);
            
            // Vis hele header-raden for debugging
            log('Header-rad lengde:', headerRow.length);
            log('Header-rad (f√∏rste 20 og siste 10):', 
                headerRow.slice(0, 20).join(' | '), 
                '...', 
                headerRow.slice(-10).join(' | '));
            
            // Sjekk ogs√• hvilken uke vi faktisk er i
            log(`Current week er: ${currentWeek}`);
            
            const bestMatch = findBestWeekMatch(weekColumns, currentWeek);
            
            if (!bestMatch) {
                const uniqueWeeks = [...new Set(foundWeeks)].sort((a, b) => a - b);
                throw new Error(`Kunne ikke finne kolonne for uke ${currentWeek}. Tilgjengelige uker: ${uniqueWeeks.join(', ')}`);
            }
            
            weekColumnIndex = bestMatch.columnIndex;
            log(`‚úÖ Bruker uke ${bestMatch.week} p√• kolonne-indeks ${weekColumnIndex} (s√∏kte etter uke ${currentWeek}) ‚Äî matchType: ${bestMatch.matchType}`);
            
            // Viktig: Hvis vi ikke fant eksakt match, gi en advarsel
            if (bestMatch.matchType !== 'exact') {
                console.warn(`‚ö†Ô∏è ADVARSEL: Fant ikke eksakt match for uke ${currentWeek}. Bruker uke ${bestMatch.week} i stedet (matchType: ${bestMatch.matchType}).`);
                console.warn(`Dette kan bety at uke ${currentWeek} ikke finnes i dataene, eller at kombineringslogikken ikke fungerer riktig.`);
            }
            
            // Finn raden for "Havet Arena"
            for (let i = headerRowIndex + 1; i < lines.length; i++) {
                const row = lines[i];
                if (row.length > 0) {
                    const firstCell = row[0].toLowerCase().trim();
                    // Mer robust sjekk for "Havet Arena" (t√•ler ekstra mellomrom etc.)
                    if (firstCell.includes('havet') && firstCell.includes('arena')) {
                        havetArenaRowIndex = i;
                        log('Fant Havet Arena-rad p√• indeks:', i);
                        break;
                    }
                }
            }
            
            if (havetArenaRowIndex === -1) {
                throw new Error('Kunne ikke finne rad for "Havet Arena"');
            }
            
            // Hent verdien fra riktig kolonne i Havet Arena-raden
            const havetArenaRow = lines[havetArenaRowIndex];
            if (havetArenaRow.length <= weekColumnIndex) {
                throw new Error(`Havet Arena-rad har ikke nok kolonner (har ${havetArenaRow.length}, trenger ${weekColumnIndex + 1})`);
            }
            
            const valueStr = havetArenaRow[weekColumnIndex].trim();
            log(`Verdi fra kolonne ${weekColumnIndex} (uke ${currentWeek}):`, valueStr);
            
            // H√•ndter spesielle verdier som "*", ">2420", osv.
            let foundValue = null;
            let isEstimate = false;
            let rawValue = valueStr;
            
            // Funksjon for √• rense og parse verdi
            const parseValue = (val) => {
                if (!val || val === '*' || val === '-') return { value: null, isEstimate: false };
                let clean = val;
                let estimated = false;
                if (clean.startsWith('>')) {
                    estimated = true;
                    clean = clean.substring(1);
                }
                clean = clean.replace(/[^\d.-]/g, '');
                const num = parseFloat(clean);
                return isNaN(num) ? { value: null, isEstimate: estimated } : { value: num, isEstimate: estimated };
            };

            const parsed = parseValue(valueStr);
            foundValue = parsed.value;
            isEstimate = parsed.isEstimate;
            
            // Hvis vi ikke fant verdi for gjeldende uke, pr√∏v KUN forrige uke
            let actualWeek = bestMatch ? bestMatch.week : currentWeek;
            
            if (foundValue === null) {
                log(`Ingen verdi funnet for uke ${currentWeek}, pr√∏ver forrige uke...`);
                
                const prevWeek = currentWeek - 1;
                const prevWeekMatch = weekColumns.find(w => w.week === prevWeek);
                
                if (prevWeekMatch) {
                    const prevValueStr = havetArenaRow[prevWeekMatch.columnIndex]
                        ? havetArenaRow[prevWeekMatch.columnIndex].trim()
                        : '';
                    const prevParsed = parseValue(prevValueStr);
                    
                    if (prevParsed.value !== null) {
                        foundValue = prevParsed.value;
                        isEstimate = prevParsed.isEstimate;
                        rawValue = prevValueStr;
                        actualWeek = prevWeek;
                        log(`Fant verdi for forrige uke (${prevWeek}):`, foundValue);
                    }
                }
            }
            
            // Hvis vi ikke fant noe, vis hvilke uker som faktisk finnes
            const uniqueWeeks = [...new Set(foundWeeks)].sort((a, b) => a - b);
            if (foundValue === null) {
                log('Fant ingen verdi. Tilgjengelige uker i data:', uniqueWeeks);
                log('S√∏kte etter uke:', currentWeek);
                
                // Hvis verdien er null fordi det var "*" eller lignende, gi en annen melding
                if (valueStr === '*' || valueStr === '' || valueStr === '-') {
                    return {
                        value: null,
                        error: `Ingen verdi registrert for uke ${currentWeek} (markert som "${valueStr}"). Tilgjengelige uker i data: ${uniqueWeeks.join(', ')}`,
                        availableWeeks: uniqueWeeks,
                        searchedWeek: currentWeek
                    };
                }
                
                // Hvis vi ikke fant noen uker i det hele tatt, vis r√•dataene
                let debugInfo = '';
                if (uniqueWeeks.length === 0) {
                    debugInfo = '\n\nüîç Debug-info:\n';
                    debugInfo += `‚Ä¢ Antall rader: ${lines.length}\n`;
                    debugInfo += `‚Ä¢ Header-rad indeks: ${headerRowIndex}\n`;
                    debugInfo += `‚Ä¢ Uke-kolonne indeks: ${weekColumnIndex}\n`;
                    debugInfo += `‚Ä¢ Havet Arena-rad indeks: ${havetArenaRowIndex}\n`;
                    debugInfo += '\nF√∏rste 5 rader:\n';
                    for (let i = 0; i < Math.min(5, lines.length); i++) {
                        debugInfo += `  Rad ${i}: ${lines[i].join(' | ')}\n`;
                    }
                    debugInfo += '\nüí° Sjekk konsollen (F12) for mer detaljer.';
                }
                
                // Returner et objekt med feilinfo
                return {
                    value: null,
                    error: `Kunne ikke finne verdi for uke ${currentWeek}.${uniqueWeeks.length > 0 ? ' Tilgjengelige uker i data: ' + uniqueWeeks.join(', ') : ' Ingen uke-verdier funnet i dataene.'}${debugInfo}`,
                    availableWeeks: uniqueWeeks,
                    searchedWeek: currentWeek,
                    rawData: lines.slice(0, 10) // Lagre f√∏rste 10 rader for debugging
                };
            }

            // Bygg historikk for siste uker (bruker kun uker med gyldig tallverdi)
            const weekValues = weekColumns
                .slice()
                .sort((a, b) => a.week - b.week)
                .map(w => {
                    const cellVal = havetArenaRow[w.columnIndex] ? havetArenaRow[w.columnIndex].trim() : '';
                    const parsedVal = parseValue(cellVal);
                    return parsedVal.value === null ? null : { week: w.week, value: parsedVal.value };
                })
                .filter(v => v !== null);

            const history = weekValues.slice(-5);
            
            return {
                value: foundValue,
                availableWeeks: uniqueWeeks,
                searchedWeek: currentWeek,
                actualWeek: actualWeek, // Hvilken uke som faktisk ble brukt
                isEstimate,
                rawValue,
                history
            };
        }

        // === UI / VISNING ===

        // Vis en enkel graf over siste uker
        function createMiniChart(weekData = []) {
            const canvas = document.createElement('canvas');
            canvas.width = 200;
            canvas.height = 100;
            const ctx = canvas.getContext('2d');
            if (!ctx || weekData.length === 0) return canvas;

            const maxVal = Math.max(...weekData);
            const minVal = Math.min(...weekData);
            const padX = 10;
            const padY = 10;
            const span = Math.max(1, maxVal - minVal);

            ctx.strokeStyle = '#667eea';
            ctx.lineWidth = 2;
            ctx.beginPath();
            weekData.forEach((val, idx) => {
                const x = padX + (idx / Math.max(1, weekData.length - 1)) * (canvas.width - 2 * padX);
                const yNorm = (val - minVal) / span;
                const y = canvas.height - padY - yNorm * (canvas.height - 2 * padY);
                if (idx === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            });
            ctx.stroke();

            // Tegn punkter
            ctx.fillStyle = '#ffffff';
            ctx.strokeStyle = '#667eea';
            weekData.forEach((val, idx) => {
                const x = padX + (idx / Math.max(1, weekData.length - 1)) * (canvas.width - 2 * padX);
                const yNorm = (val - minVal) / span;
                const y = canvas.height - padY - yNorm * (canvas.height - 2 * padY);
                ctx.beginPath();
                ctx.arc(x, y, 3, 0, Math.PI * 2);
                ctx.fill();
                ctx.stroke();
            });

            // Enkle min/max labels til venstre
            ctx.fillStyle = '#7f8c8d';
            ctx.font = '10px Segoe UI';
            ctx.textAlign = 'left';
            ctx.textBaseline = 'top';
            ctx.fillText(`${Math.round(maxVal)}`, padX, 0);
            ctx.textBaseline = 'bottom';
            ctx.fillText(`${Math.round(minVal)}`, padX, canvas.height);

            return canvas;
        }

        // Funksjon for √• oppdatere UI
        function updateUI(result) {
            const loading = document.getElementById('loading');
            const content = document.getElementById('content');
            const valueDisplay = document.getElementById('valueDisplay');
            const statusText = document.getElementById('statusText');
            const weekInfo = document.getElementById('weekInfo');
            const error = document.getElementById('error');
            
            loading.style.display = 'none';
            error.style.display = 'none';
            
            // H√•ndter b√•de gammelt format (bare tall) og nytt format (objekt)
            let value = null;
            let errorMessage = null;
            let availableWeeks = null;
            let actualWeek = null;
            let isEstimate = false;
            let rawValue = null;
            let history = null;
            
            if (typeof result === 'object' && result !== null) {
                value = result.value;
                errorMessage = result.error;
                availableWeeks = result.availableWeeks;
                actualWeek = result.actualWeek;
                isEstimate = result.isEstimate;
                rawValue = result.rawValue;
                history = result.history;
            } else {
                value = result;
            }
            
            if (value === null || isNaN(value)) {
                error.style.display = 'block';
                if (errorMessage) {
                    error.innerHTML = errorMessage.replace(/\n/g, '<br>');
                } else {
                    const { week: currentWeek } = getWeekNumber(new Date());
                    error.textContent = 'Kunne ikke finne verdi for gjeldende uke. Sjekk at regnearket har data for uke ' + currentWeek + '.';
                }
                return;
            }
            
            content.style.display = 'block';
            
            const currentDate = new Date();
            const { week: currentWeek, year: currentWeekYear } = getWeekNumber(currentDate);
            
            valueDisplay.textContent = Math.round(value);
            
            if (value >= CONFIG.THRESHOLD_HIGH) {
                valueDisplay.className = 'value-display red';
                statusText.textContent = '‚ö†Ô∏è Ikke anbefalt for bading';
                statusText.className = 'status-text red';
            } else {
                valueDisplay.className = 'value-display green';
                statusText.textContent = '‚úÖ Trygt for bading';
                statusText.className = 'status-text green';
            }
            
            // Vis hvilken uke som faktisk ble brukt
            const weekToShow = actualWeek !== null && actualWeek !== undefined ? actualWeek : currentWeek;
            if (actualWeek !== null && actualWeek !== currentWeek) {
                weekInfo.textContent = `Uke ${weekToShow} (s√∏kte etter uke ${currentWeek}), ${currentWeekYear}`;
            } else {
                weekInfo.textContent = `Uke ${weekToShow}, ${currentWeekYear}`;
            }

            // Hvis verdien var estimert (>), vis dette som fotnote
            if (isEstimate && rawValue) {
                weekInfo.textContent += ` ‚Äî estimert verdi (${rawValue.trim()})`;
            }

            // Oppdater mini-graf hvis vi har historikk
            const historyContainer = document.getElementById('historyChart');
            if (historyContainer) {
                historyContainer.innerHTML = '';
                if (history && Array.isArray(history) && history.length > 0) {
                    log('Historikk for graf:', history);
                    const canvas = createMiniChart(history.map(h => h.value));
                    historyContainer.appendChild(canvas);
                }
            }
        }

        // Funksjon for √• rapportere feil til ekstern tjeneste (Stub)
        async function logErrorToService(error) {
            // TODO: Legg inn din webhook URL her (f.eks. Google Forms, Slack, Discord, Zapier)
            // const WEBHOOK_URL = 'DIN_WEBHOOK_URL_HER';
            
            // Hvis ingen URL er satt, bare logg til konsollen
            log('‚ö†Ô∏è Feil oppdaget! Ville sendt varsel hvis WEBHOOK_URL var konfigurert.');
            log('Feilmelding:', error.message);
            
            /* Eksempel p√• implementering:
            if (WEBHOOK_URL) {
                try {
                    await fetch(WEBHOOK_URL, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            timestamp: new Date().toISOString(),
                            error: error.message,
                            userAgent: navigator.userAgent
                        })
                    });
                } catch (e) {
                    console.error('Kunne ikke sende feilrapport:', e);
                }
            }
            */
        }

        // Enkel cache for √• unng√• un√∏dvendige requests
        async function fetchWithCache() {
            // N√•r vi debugger vil vi alltid ha ferske data
            if (CONFIG.DEBUG) {
                log('DEBUG er p√• ‚Äì skipper cache og henter ferske data');
                return await fetchSheetData();
            }

            try {
                const cachedRaw = localStorage.getItem(CONFIG.CACHE_KEY);
                if (cachedRaw) {
                    const { data, timestamp, version } = JSON.parse(cachedRaw);
                    const isFresh = Date.now() - timestamp < CONFIG.CACHE_DURATION;
                    const versionOk = version === CONFIG.CACHE_VERSION;
                    if (isFresh && versionOk) {
                        log('Bruker cached data');
                        return data;
                    }
                    log('Ignorerer cache pga utl√∏pt tid eller versjon:', { isFresh, versionOk, version, expected: CONFIG.CACHE_VERSION });
                }
            } catch (e) {
                log('Klarte ikke lese cache:', e);
            }

            const data = await fetchSheetData();

            try {
                localStorage.setItem(CONFIG.CACHE_KEY, JSON.stringify({
                    data,
                    timestamp: Date.now(),
                    version: CONFIG.CACHE_VERSION
                }));
            } catch (e) {
                log('Klarte ikke skrive cache:', e);
            }

            return data;
        }

        // === INITIALISERING ===
        // Last inn data n√•r siden laster
        document.addEventListener('DOMContentLoaded', async () => {
            // Hent temperaturer uavhengig av bakteriedata (ikke kritisk hvis det feiler)
            updateTemperature();
            updateSeaTemperature();
            
            try {
                const myRequestId = ++CURRENT_REQUEST_ID; // Marker denne foresp√∏rselen som "siste"
                const value = await fetchWithCache();
                // Hvis det har kommet en nyere foresp√∏rsel mens vi ventet,
                // skal ikke denne lenger oppdatere UI-et.
                if (myRequestId === CURRENT_REQUEST_ID) {
                updateUI(value);
                } else {
                    log('Ignorerer utdatert respons fra fetchSheetData (race condition unng√•tt).');
                }
            } catch (error) {
                document.getElementById('loading').style.display = 'none';
                document.getElementById('error').style.display = 'block';
                let errorMsg = error.message;
                
                // Rapporter feil
                logErrorToService(error);
                
                // Konverter linjeskift til HTML for bedre visning
                errorMsg = errorMsg.replace(/\n/g, '<br>');
                
                // Hvis feilmeldingen allerede inneholder detaljerte instruksjoner, vis den som HTML
                if (errorMsg.includes('<br>')) {
                    document.getElementById('error').innerHTML = errorMsg;
                } else {
                    document.getElementById('error').textContent = errorMsg;
                }
            }
        });
    </script>
</body>
</html>


